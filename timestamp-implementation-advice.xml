<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC5905 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes"?>
<?rfc toc="no"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" docName="draft-aanchal-timestamp-implementation-advice" ipr="trust200902">
  <front>
    <title>How to implement Time?</title>

    <author fullname="Aanchal Malhotra" initials="A." surname="Malhotra">
        <organization>Boston University</organization>
        <address>
            <postal>
                <street>111 Cummington Mall</street>
                <city>Boston</city>
                <region></region>
                <code>02215</code>
                <country>USA</country>
            </postal>
            <email>aanchal4@bu.edu</email>
        </address>
    </author>
    
    <author fullname="Martin Hoffmann" initials="M." surname="Hoffmann">
        <organization>Open Netlabs</organization>
        <address>
            <postal>
                <street>Science Park 400</street>
                <city>Amsterdam</city>
                <region></region>
                <code>1098 XH</code>
                <country>Netherlands</country>
            </postal>
            <email>martin@opennetlabs.com</email>
        </address>
    </author>
    
    <author fullname="Willem Toorop" initials="W." surname="Toorop">
        <organization>NLnet Labs</organization>
        <address>
            <postal>
                <street>Science Park 400</street>
                <city>Amsterdam</city>
                <region></region>
                <code>1098 XH</code>
                <country>Netherlands</country>
            </postal>
            <email>willem@nlnetlabs.nl</email>
        </address>
    </author>

    <date year="2017" month="October" day="30"/>

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>timestamps</keyword>

    <keyword>timespans</keyword>

    <abstract>
      <t>This document describes the properties of different types of time
        values available on digital systems and provide guidance on choice of these time values to the implementors for applications that use time in some form to provide the basic functionality and/or security guarantees.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The basic functionality and security guarantees claimed by many
        applications running on digital systems locally or in the Internet hinges on some notion of time. These applications have to choose one of the many types of time values available on the system, each of which has its own specific properties. However, currently these
        applications seem to be oblivious to the implications of choosing one or the other time value for implementation. This behaviour can be attributed to: a) the lack of clear understanding of the distinct properties of these time values, b) Trade-offs of using one or the other for an application, and c) availability and compatibilty of these time values on different operating systems.</t>

        <t>In this document we describe the properties of various available time values on modern operating systems, discuss the trade-offs of using one over the other, and provide guidance to help implementors make an informed choice with some real-life examples.</t>
   
      <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
          document are to be interpreted as described in <xref
              target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section>

      <section title="Keeping Time: Different Clocks">
          <t> Because time is relative to an observer, there cannot be a
              universally agreed upon time. At best we can achieve an
              approximation by updating our own observed time with a
              common reference time shared with other observers.</t>

      <t>As this reference time is what we naively assume clocks on a wall are
        showing, we shall call it the "wall time." For most applications, it is based on the Universal Coordinated Time (UTC), an international standard time determined by averaging the output of several high-precision time-keeping devices. However, as UTC is following Earth's solar time, it occasionally needs to be adjusted through leap seconds.</t>
              
      <t> An individual computer system's preception of time differs from that
        of this idealized wall time. Staying close to it requires some effort that comes with its own set up drawbacks. Systems therefore provide access to different types of clocks with different properties. Unfortunately, there is no standard terminology and definitions for these types. For the purpose of this document, we therefore define three different kinds of clocks that a system may or may not provide.</t>

          <section title="Raw Time">
              <t> At its most fundamental, a system has its own perception of
                  time; its unmodified, "raw time." This time is typically measured
                  by counting cycles of an oscillator. Its quality therefore relies on the
                  stability of this oscillator.</t>
              <t> As it is a purely subjective time, no general meaning can be
                  attached to any specific value. Only the amount of time passed
                  can be determined by comparing two values.</t>
              <t> Because raw time is unaltered, its value is increasing monotonically
                  at a near constant rate.</t>
          </section>
          <section title="Adjusted Raw Time">
              <t> Even if highly accurate oscillators are used, raw time passes at a
                  slightly different rate than wall time. This difference is called
                  clock drift. It depends not only on the quality of the time source but
                  also on environmental factors such as temperature.</t>
              <t> When this drift is componsated by comparing the passage of raw time
                  to some external time source that is considered to be closer to
                  wall time, the result is "adjusted raw time." This adjustment doesn't
                  happen sporatically but rather, time is slowed or sped up slightly
                  until it approaches the reference time again. As a result, adjusted
                  raw time is still monotonic. Like raw time, adjusted raw time is
                  subjective with no specific meaning attached to any value.</t>
              <t> The most frequently used method of acquiring an external time source
                  is through network timing protocols such as NTP
                  <xref target="RFC5905"/>. As a
                  result, adjusted raw time is susceptible to vulnerabilites of these
                  protocols which may be used to maliciously manipulate this time.</t>
          </section>
          <section title="Real Time">
              <t> With adjusted raw time, a system already has access to a time that
                  passes at a rate very similar to wall time. By adjusting the time
                  value so that it represents the time passed since the epoch, a
                  well-defined point of wall time such as seconds since midnight
                  January 1st, 1970 on Unix systems, time values themselves gather
                  meaning. The result is "real time."</t>
              <t> While it is often assumed that real time is set to match wall time,
                  this doesn't need to be the case. An system's operator is free to
                  change the value of real time at any time, likewise, system services
                  such as a local NTP client may decide to do so.</t>
              <t> As a consequence, real time is not monotonic. Not only may it
                  jump forward, its value may even decrease.</t>
          </section>
          <section title="Differences from Wall Time">
              <t> These three clock types differ from wall time in three aspects.</t>
              <t> Both raw time and adjusted raw time can only represent differences
                  in time by comparing two clock values. Only real time provides
                  absolute time values that can be compared to wall time values.</t>
              <t> On the other hand, raw time and adjusted raw time are montonically
                  increasing whereas real time may experience sudden changes in its
                  value.</t>
              <t> Only adjusted raw time and real time are adjusted so that time
                  passes at approximately the same rate as wall time. Raw time will
                  over time drift away due to inevitable imperfection of the clock.</t>
          </section>
      </section>

    <section title="Expressing Time">
        <t> Protocols or applications can express time in one of two forms,
            depending on whether global agreement over the point in time
            is necessary.</t>

        <section title="Time Stamps">
            <t> A time stamp expresses an absolute point in
                time. In order to reference the same point across multiple
                systems, it needs to be stated in wall time.</t>
            <t> Time stamps are often used to express the validity of
                objects with a limited lifetime that are shared over the
                network. For instance, PKIX certificates
                <xref target="RFC5280"/> carry two time stamps expressing
                their earliest and latest validity.</t>
            <t> While time stamps are sometimes provided similarly to real
                time as the time passed since a well-defined epoch, often
                they are expressed as a complext date and time value tailored
                for human consumption.</t>
            <t> In order to validate a time stamp, a system needs access to
                a clock that is reasonably close to wall time.</t>
        </section>

        <section title="Time Spans">
            <t> In contrast, a time span expresses a desired
                length of time. Examples of time spans are time-out values used
                in protocols to determine packet loss or Time to Live (TTL)
                values that govern the lifetime of a local copy of an object.</t>
            <t> While no access to wall time is necessary for correctly dealing
                with time spans, using a clock whose time passes at a different
                rate than wall time's will result in different interpretations
                of time spans by different systems. However, in a network
                environment, the uncertainty introduced by differing transmission
                times is likely larger than that introduced by clock drift.</t>
        </section>
    </section>
    <section anchor="CURIMP" title = "Current Implementation and Why is it bad?">
        <t>Currently, some softwares takes a common approach towards time stamps and time spans.
	   Time stamps are registered with their wall time value, and time spans are registered with two time stamp values marking the start and the end of the span.
	   Conversion of a time span into those time stamp markers is regularly based on real time.
	</t>
	<t>Note that the start of a time span will be the current (real) time in case of a TTL.
	   So, in case something needs to be cached for a certain time, the start time stamp is irrelevant and it is registered together with only the (real) expiration time.</t>
	<t>Programmers might have had different reasons to base those markings on real time, for example:<list style="numbers">
	  <t>A point in time is intuitively thought of as a wall clock time stamp.
	  Time stamps from outside the software, which the software has to manage are already in wall clock time.
	  The POSIX function to get the current (real) time which is regularly used for this, is gettimeofday(), which comes accross as something providing near wall clock time and which can be used for this purpose.
	  </t>
	  <t>Managing time stamps and time span similarly, prevents code complexity.
	  <vspace blankLines="1" />
	  For example, many software is organized around I/O event notification mechanisms like the POSIX select() and poll() system C API functions.
	  These functions wait for a given time span for file descriptors to become ready to perform I/O.
	  The given time span is determined by substracting the smallest registered time stamp by the current real time value.
	  When file descriptors are ready, the non-blocking I/O is performed, otherwise the given time span has passed and the action associated with the smallest registered time stamp needs to be performed.
	  <vspace blankLines="1" />
	  For this programming pattern, a sorted list of time stamps has to be maintained by the software.
	  To avoid coding complexity, programmers might prefer a single list for both actual wall clock time stamps and on real time based generated time stamps marking the end points of a time span.
	  </t>
	</list></t>

            <t>Using real time as a basis for the time stamps marking the start and end of a time span is bad because of the following reasons.
                </t>
            <t><list style="numbers">
                <t>It can be set or overwritten manually,</t>
            <t>It is subject to adjustments by timing protocols which on one hand is important to
                make sure that this time is in sync with the rest of the world but on the other
                hand makes it dependent on the correctness and security of timing protocols.</t>
            </list></t>
           <t> Recent attacks <xref target="SECNTP"></xref>,<xref target="SECNTP1"></xref> show how timing protocols
               like NTP can be leveraged to shift real time on systems.</t>
           <t>Time stamps are always based on wall time, so the best one can do is to use real time
               while dealing with them. However, this limitation does not hold for the time spans.
	       Managin time spans may be implemented in alternative ways which may prove to be more secure and robust.</t>
           
        <t><list>
        <t>An obvious question to ask is: Why do we need inception and expiration time stamps in the first place to define the validity period of cryptographic objects?
	   Why can not we just use time spans like TTL values instead?
           The reason is straightforward.
	   <vspace blankLines="1" />
	   The authority determining and setting the validity period on the object can be different from the operator delivering the object.
	   For example the TTL value on DNS resource records, indicate caching DNS resolvers how long to cache those records.
	   These are an operational matter and are thus left to the operators of the DNS zone.
	   <vspace blankLines="1" />
	   The content of the resource records are however determined by the signer of the records.
	   When she is not the zone operator too, she has no way to determine when the records will be queried for, and thus has to depend on cryptographically signed wall clock based time stamps to limit the validity.
	   <vspace blankLines="1" />
	   Note however that DNSSEC signatures do contain the original TTL of a resource record set, restricting the maximum TTL value with which the operator may deliver the resource records.  </t>
	</list></t>
        
	<!-- <t>Since we have no choice but to use real time for time stamps, for the rest of the document we only discuss the case of time spans.</t> -->

        </section>
    <section anchor="ALTIMP" title = "Alternative Approaches">
        <t>For time spans, where we only need the rate of passage of time to be same/close enough to the rest of the world,
            one SHOULD not use the real time to establish the start and end time mark for the reasons mentioned above.
            The other two types of time are raw time and adjusted raw time. The important aspect of these monotonic time
            sources is not their current value, but the guarantee that the time source is strictly linearly increasing, and
            thus useful for calculating the difference in time between two samplings. But each comes with its own caveats.</t>
        <t><list>
            <t> Raw Time is not subject to any adjustments by timing protocols i.e. it is not adjusted for the error
                introduced by frequency drift of the local oscillator. This could have two repurcussions. First, this
                makes correctness of raw time independent of the errors or security vulnerabilities of the timing protocols. Second, its
                correctness depends on the frequency drift which further depends on various factors such as quality of quartz
                or work load or ambient temperature on the system and may vary.</t>
           <t> Adjusted Raw Time, on the other hand, is subject to adjustments by timing protocols and so is compensated for
               the errors introduced due to frequency drift of the local clock. However, this time could be bad as it is
               vulnerable to accuracy and security vulnerabilities of the underlying timing protocol.</t>
           </list></t>
            
            <t>The choice of time value to be used is application-specific. For instance in applications that can tolerate a certain amount of
                <xref target="CLOCKDRIFT">clock drift</xref>, can use raw time. However, if that is an issue then one has no choice but to fallback to adjusted raw time.</t>
	<t>POSIX defines a system C API function which may provide raw time: clock_gettime(), when used with a clock_id of CLOCK_MONOTONIC (when supported by the system).
           POSIX does not make a distinction between raw time and adjusted raw time in the definition of this function.
	   Beware however that with some systems CLOCK_MONOTONIC deliveres adjusted raw time and that CLOCK_MONOTONIC_RAW needs to be used as clock_id to get unadjusted raw time.</t>
	<t>Software employing the pattern organized around I/O event notification mechanisms, as described in section <xref target="CURIMP" /> should maintain two sorted lists of two different types of time stamps:<list style="numbers">
	<t>One to register events based on time stamps expressed in wall clock time</t>
	<t>One to register the start and end of time spans in (adjusted) raw time</t>
	</list></t>
	<t>To determine the timeout value for a call to select() or poll(), the program needs to get the current time in both real time and in (adjusted) raw time.
	The current real time is substracted from the lowest value of the time stamps expressed in wall time list.
	The current (adjusted) raw time from the lowest value of the time stamps expressed in (adjusted) raw time list.
	The lowest of the values should be used as the timeout value for select() or poll() and determines which action should be performed when te function times out.</t>
	<t>Alternatively a single list of (adjusted) raw time could be used for both time stamps and time spans.
	   In that case time stamps expressed in wall clock time should be converted into (adjusted) raw time, by first converting it into a time span by substracting real time from it, and then adding the current time in (adjested) raw time.</t>
        </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We are thankful to Sharon Goldberg and Benno Overreinder for useful 
        discussions.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>
        
    <section title = "Security Considerations">
        <t>Beware that clock_gettime() when used with clock_id CLOCK_MONOTONIC does not deliver raw time and could deliver adjusted raw time on some systems.
	On those systems CLOCK_MONOTONIC_RAW needs to be used to get unadjusted raw time as descriped in section <xref target="ALTIMP" />.</t>
        </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC2119;


    </references>

    <references title="Informative References">
      &RFC5280;
      &RFC5905;

      <reference anchor="SECNTP" target="http://eprint.iacr.org/2016/1006">
        <front>
          <title>The Security of NTP's Datagram Protocol</title>

          <author initials="A." surname="Malhotra" fullname="A. Malhotra">
            <organization/>
          </author>
          <author initials="M. V." surname="Gundy" fullname="M. V. Gundy">
            <organization/>
          </author>
          <author initials="M." surname="Varia" fullname="M. Varia">
            <organization/>
          </author>
          <author initials="H." surname="Kennedy" fullname="H. Kennedy">
            <organization/>
          </author>
          <author initials="J." surname="Gardner" fullname="J. Gardner">
            <organization/>
          </author>
          <author initials="S." surname="Goldberg" fullname="S. Goldberg">
            <organization/>
          </author>

          <date year="2016"/>
          </front>
          </reference>
        
      <reference anchor="SECNTP1" target="https://eprint.iacr.org/2015/1020">
        <front>
            <title>Attacking the Network Time Protocol</title>
            
            <author initials="A." surname="Malhotra" fullname="A. Malhotra">
                <organization/>
            </author>
            <author initials="I." surname="Cohen" fullname="I. Cohen">
                <organization/>
            </author>
            <author initials="E." surname="Brakke" fullname="E. Brakke">
                <organization/>
            </author>
            <author initials="S." surname="Goldberg" fullname="S. Goldberg">
                <organization/>
            </author>
            
            <date year="2015"/>
        </front>
      </reference>

      <reference anchor="CLOCKDRIFT" target="http://downloads.hindawi.com/journals/jcnc/2008/583162.pdf">
        <front>
            <title>Internal clock drift estimation in computer clusters</title>
            
            <author initials="H." surname="Marouani" fullname="H. Marouani">
                <organization/>
            </author>
            <author initials="M. R." surname="Dagenais" fullname="M. R. Dagenais">
                <organization/>
            </author>
            <date year="2008"/>
        </front>
      </reference>

    </references>
  </back>
</rfc>
